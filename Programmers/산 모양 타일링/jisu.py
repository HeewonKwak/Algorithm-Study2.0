"""
풀이 시간 : 3시간 초과 후 풀이 참고 ([ref](https://tech.kakao.com/2023/12/27/2024-coding-test-winter-internship/))
[기존 접근]
- 아래 방향 정삼각형 하나를 포함한 산 모양 타일 x 왼쪽 정삼각형 제외한 산 모양 타일을 계속해서 Tabulation
- 모든 케이스를 고려하지 못해 n>=2 부터 오답
[ref 접근]
- 아래 방향 정삼각형을 어떻게 덮을지에 따라 case 분할,
    - 1. 위쪽 정삼각형과 함께 마름모 타일로 덮기
    - 2. 왼쪽 정삼각형과 함께 우향 평행사변형으로 덮기
    - 3. 오른쪽 정삼각형과 함께 좌향 평행사변형으로 덮기
    - 4. 정삼각형으로 덮기
- k-1번째에서 3으로 아래 방향 정삼각형을 덮은 경우 k번째에서 2 적용 불가
    - 직전 방법이 3인지 여부에 따라 다음 방법에 영향을 미침, 따라서 두 개의 배열을 정의해 각 점화식에 따라 Tabulation
    - a[k] = k번째 아래 방향 정삼각형까지 덮었을 때, k번째 정삼각형을 3으로 덮은 경우
    - b[k] = k번째 아래 방향 정삼각형까지 덮었을 때, k번째 정삼각형을 1, 2, 4로 덮은 경우
- top[k]가 1인 경우 (1, 2, 3, 4) 모두 가능
    - a[k] = 이전 방법에 대한 경우의 수(a[k-1], b[k-1])에 대해 모두 3 적용 가능
    - b[k] = 이전 방법이 3인 경우(a[k-1]) 1, 4 적용 가능 / 이전 방법이 3이 아닌 경우(b[k-1]) 1, 2, 4 적용 가능
- top[k]가 0인 경우 (2, 3, 4) 가능
    - a[k] = 이전 방법에 대한 경우의 수(a[k-1], b[k-1])에 대해 모두 3 적용 가능
    - b[k] = 이전 방법이 3인 경우(a[k-1]) 4 적용 가능 / 이전 방법이 3이 아닌 경우(b[k-1]) 2, 4 적용 가능
"""
from typing import List

MOD = 10007


def solution(n: int, tops: List[int]) -> int:

    a = [0 for _ in range(n)]   # a[k] : k번째 아래 방향 정삼각형을 3번 방법으로 덮은 경우의 수
    b = [0 for _ in range(n)]   # b[k] : k번째 아래 방향 정삼각형을 1, 2, 4번 방법으로 덮은 경우의 수

    a[0] = 1
    b[0] = 3 if tops[0] else 2

    for k in range(1, n):
        if tops[k]:
            a[k] = a[k-1] + b[k-1]          # 이전 방법에 대한 경우의 수에 대해 모두 3 적용 가능
            b[k] = a[k-1] * 2 + b[k-1] * 3  # 이전 방법이 3인 경우 1, 4 적용 가능 + 이전 방법이 3이 아닌 경우 1, 2, 4 적용 가능
        else:
            a[k] = a[k-1] + b[k-1]          # 이전 방법에 대한 경우의 수에 대해 모두 3 적용 가능
            b[k] = a[k-1] + b[k-1] * 2      # 이전 방법이 3인 경우 4 적용 가능 + 이전 방법이 3이 아닌 경우 2, 4 적용 가능

        a[k] %= MOD     # 주의. 매 연산마다 MOD해주지 않으면 TLE
        b[k] %= MOD

    return (a[-1]+b[-1]) % MOD


def main() -> None:
    case1 = [4, [1, 1, 0, 1]]
    case2 = [2, [0, 1]]
    case3 = [10, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

    print(solution(*case1))  # 149
    print(solution(*case2))  # 11
    print(solution(*case3))  # 7704


main()
